{
  "version": 3,
  "sources": ["../@material-ui/core/esm/utils/setRef.js", "../@material-ui/core/esm/utils/useEventCallback.js", "../@material-ui/core/esm/utils/useForkRef.js"],
  "sourcesContent": ["// TODO v5: consider to make it private\nexport default function setRef(ref, value) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n}", "import * as React from 'react';\nvar useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\n/**\n * https://github.com/facebook/react/issues/14099#issuecomment-440013892\n *\n * @param {function} fn\n */\n\nexport default function useEventCallback(fn) {\n  var ref = React.useRef(fn);\n  useEnhancedEffect(function () {\n    ref.current = fn;\n  });\n  return React.useCallback(function () {\n    return (0, ref.current).apply(void 0, arguments);\n  }, []);\n}", "import * as React from 'react';\nimport setRef from './setRef';\nexport default function useForkRef(refA, refB) {\n  /**\n   * This will create a new function if the ref props change and are defined.\n   * This means react will call the old forkRef with `null` and the new forkRef\n   * with the ref. Cleanup naturally emerges from this behavior\n   */\n  return React.useMemo(function () {\n    if (refA == null && refB == null) {\n      return null;\n    }\n\n    return function (refValue) {\n      setRef(refA, refValue);\n      setRef(refB, refValue);\n    };\n  }, [refA, refB]);\n}"],
  "mappings": ";;;;;;;;AACe,gBAAgB,KAAK,OAAO;AACzC,MAAI,OAAO,QAAQ,YAAY;AAC7B,QAAI;AAAA,aACK,KAAK;AACd,QAAI,UAAU;AAAA;AAAA;;;ACLlB,YAAuB;AACvB,IAAI,oBAAoB,OAAO,WAAW,cAAoB,wBAAwB;AAOvE,0BAA0B,IAAI;AAC3C,MAAI,MAAM,AAAM,aAAO;AACvB,oBAAkB,WAAY;AAC5B,QAAI,UAAU;AAAA;AAEhB,SAAO,AAAM,kBAAY,WAAY;AACnC,WAAQ,IAAG,IAAI,SAAS,MAAM,QAAQ;AAAA,KACrC;AAAA;;;ACfL,aAAuB;AAER,oBAAoB,MAAM,MAAM;AAM7C,SAAO,AAAM,eAAQ,WAAY;AAC/B,QAAI,QAAQ,QAAQ,QAAQ,MAAM;AAChC,aAAO;AAAA;AAGT,WAAO,SAAU,UAAU;AACzB,aAAO,MAAM;AACb,aAAO,MAAM;AAAA;AAAA,KAEd,CAAC,MAAM;AAAA;",
  "names": []
}
